## 1.1 Unix历史

Unix是从贝尔实验室的一个失败的多用户操作系统Multics中涅槃而生的。

1969年的夏天，贝尔实验室的程序员们设计了一个文件系统原型，而这个原型最终发展演化成了Unix。

1973年，整个Unix操作系统用C语言进行了重写。

第一个在贝尔实验室以外被广泛使用的Unix版本是第6版，称为V6。

**Unix强大的几个根本原因：**

第一：Unix很**简洁**：不像其他动辄提供数千个系统调用并且设计目的不明确的系统，Unix仅仅提供几百个系统调用并且有一个非常明确的设计目的。

第二：在Unix中，所有的东西都被当做**文件**对待（不是所有，如socket）。这种抽象使对数据和对设备的操作是通过一套相同的系统调用接口来进行的。

第三：Unix的内核和相关的系统工具软件是用C语言编写而成的，使得Unix在各种硬件体系架构面前都具备令人惊异的**一致**能力。

第四：Unix的**进程创建**非常迅速，并且有一个非常独特的fork()系统调用。

最后，Unix提供一套非常简单但又非常简单但又很稳定的**进程间通信**元语，快速简洁的进程创建过程使Unix的程序把目标放在一次执行保质保量地完成一个任务上，而简单稳定的进程间通信机制又可以保证这些单一目的的简单程序可以方便地组合在一起，去解决现实中变得越来越复杂的任务。正式由于这种策略和机制分离的设计理念，确保了Unix系统具备清晰的层次化结构。

如今，Unix已经发展成为一个支持抢占式多任务、多线程、虚拟内存、换页、动态链接和TCP/IP网络的现代化操作系统。

## 1.2 Linux简介

1991年，Linus Torvalds为当时新推出的、使用Intel 80386微处理器的计算机开发了一款全新的操作系统，Linux由此诞生。

到现在，Linux早已羽翼丰满，它被广泛移植到Alpha、ARM、PowerPC、SPARC、x86-64等许多其他体系结构之上。

Linux是类Unix系统，但它不是Unix。尽管Linux借鉴了Unix的许多设计并且实现了Unix的API,但Linux没有像其他Unix变种那样直接使用Unix的源代码。

Linux内核也是自由（公开）软件，它使用GNU的General Public License(GPL)第2版作为限制条款。我们可以自由地获取内核代码并随意修改它，但如果我们要发布修改过的内核，也得保证让得到内核的人同时享有我们曾经享受过的所有权利，当然，包括全部的源代码。

## 1.3 操作系统和内核简介

**操作系统**是指在整个系统中复杂完成最基本功能和系统管理的那些部分。包括内核、设备驱动程序、启动引导程序、命令行shell或者其他种类的用户界面、基本的文件管理工具和系统工具。

内核有时候被称作管理者或者操作系统核心。

通常一个内核由复杂响应中断的中断服务程序，复杂管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网路、进程间通信等系统服务共同组成。

对于提供保护机制的现代系统来说，内核独立于普通应用程序，它一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限。这种系统和被保护起来的内存空间，统称为**内核空间**。

当内核运行的时候，系统以内核态进入内核空间执行。而执行一个普通用户程序时，系统将以用户态进入以用户空间执行。

在系统中运行的应用程序通过**系统调用**来与内核通信。应用程序通常调用库函数再由库函数通过系统调用界面，让内核代其完成各种不同任务。

一些库调用提供了系统调用不具备的许多功能，在那些较为复杂的函数中，调用内核的操作通常只是整个工作的一个步骤。如：

	1. printf()函数，它提供了数据的缓存和格式化等操作，而调用write()函数将数据写到控制台上只是其中的一个动作。
	2. 也有一些库函数和系统调用就是一一对应的关系，比如，open()库函数除了调用open()系统调用之外，几乎什么也没做。
	3. 还有一个C库函数，像strcpy（），根本就不需要直接调用系统及的操作。

当一个应用程序执行一条系统调用，应用程序被称为通过系统调用在**内核空间**中运行，而内核被称为运行于**进程上下文**中。

这种交互方式--**应用程序通过系统调用界面陷入内核**--是应用程序完成其工作的基本行为方式。



内核还有负责管理系统的硬件设备。现有的几乎所有的体系结构，包括全部Linux支持的体系结构，都提供了**中断机制**。

当硬件设备想和系统通信的时候，它首先要发出一个异步的中断信号去打断处理器的执行，继而打断内核的执行。

中断通常对应着一个中断号，内核通过这个中断号查找相应的中断服务程序，并调用这个程序响应和处理中断。

许多操作系统的中断服务程序，包括Linux的，都不在进程上下文中执行。它们在一个与所有进程都无关的、专门的中断上下文中运行。

这些上下文代表着内核活动的范围。处理器在任何指定时间点上的活动必然为以下三者之一：

	1. 运行于用户空间，执行用户进程。
	2. 运行于内核空间，处于进程上下文，代表某个特定的进程执行。
	3. 运行于内核空间，处理中断上下文，与任何进程无关，处理某个特定的中断。

<img src = "https://img-blog.csdnimg.cn/20190911175408307.png" width = "80%">

## 1.4 Linux内核和传统的Unix内核的比较

Unix内核几乎毫无例外的都是一个不可分割的静态可执行库。也就是说，它们必须以巨大、单独的可执行块的形式在一个单独的地址空间中运行。

Unix内核通常需要硬件系统提供**页机制（MMU)**以管理内存，这种页机制可以加强对内存空间的保护，并保护每个进程都可以运行于不同的虚地址空间上。

初期的Linux系统也需要MMU支持，但有一些特殊版本并不依赖于此。

**单内核与微内核设计之比较**

操作系统内核可以分为两大阵营：**单内核**和**微内核**（第三阵营是外内核，主要用在科研系统中）。

1980年以前，所有的内核都设计成单内核。所谓单内核就是把它从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上。因此，这样的内核通常以单个静态二进制文件的形式存放于磁盘中。所有的内核服务都在这样的一个大内核地址空间上运行。内核之间的通信时微不足道的，因为大家都运行在内核态，斌处于同一地址空间：内核可以直接调用函数，这与用户空间应用程序没有什么区别。

单内核具有简单和性能高的特点。大多数Unix系统都设计为单内核。

微内核并不作为一个单独的大过程来实现。相反，微内核的功能被划分为多个独立的进程，每个过程叫做一个服务器。理想情况下，只有强烈请求特权服务的服务器才运行在特权模式下，其他服务器都运行在用户空间。不过，所有的服务器都保持独立并运行在各自的地址空间上。因此，就不可能像单模块内核那样直接调用函数，而是通过消息传递处理微内核通信：系统采用了**进程间通信**（`IPC`)机制。服务器的各自独立有效地避免了一个服务器失效祸及另一个。

因为IPC机制的开销多余函数调用，又因为涉及内核空间与用户空间的上下文切换，因此，消息传递需要一定的周期，而单内核中简单的函数调用没有这些开销。结果，所有实际应用的基于微内核的系统都让大部分或全部服务器位于内核，这样就可以直接调用函数，消除频繁的上下文切换。

Windows NT内核和Mach是微内核的典型实例，单它们在其最新的版本中不让任何微内核服务器运行在用户空间，这违背了微内核设计的初衷。

Linux是一个单内核，运行在单独的内核地址空间上。不过，Linux汲取了微内核的精华：模块化设计、抢占式内核、支持内核线程以及动态装载内核模块的能力。不仅如此，Linux还避免了微内核设计上性能损失的缺陷，让所有事情都运行在内核态，直接调用函数。

Linux内核与传统的Unix系统之间存在一些显著的差异：

	1. Linux支持动态加载内核模块。
	2. Linux支持对称多处理（SMP)机制，传统的Unix并不支持这种机制。
	3. Linux内核可抢占，大多数Unix内核不支持抢占。
	4. Linux内核不区分线程和其他的一般进程。
	5. Linux提供具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设备文件系统（sysfs)。
	6. Linux忽略了一些被认为是设计得很拙劣得Unix特性以及一些难以实现得过时标准。

## 1.5 Linux内核版本

Linux内核有两种：**稳定版**和**开发板**。

其中，稳定得内核具有工业级的强度，可以广泛地应用和部署。

Linux内核版本的命名机制为：主版本号.从版本号.修订版本号(.稳定版本号)
